#!/usr/bin/env python3
"""
SQLite Database Management Tool
Auto-generated by Chotu Self-Learning System
Provides CRUD operations for SQLite databases
"""

import sqlite3
import os
import json
from typing import Dict, List, Any, Optional

class SQLiteDatabaseTool:
    """SQLite database management with CRUD operations"""
    
    def __init__(self, db_path: str = None):
        """Initialize the database tool"""
        self.db_path = db_path or "chotu_database.db"
        self.connection = None
        
    def connect(self) -> bool:
        """Connect to the SQLite database"""
        try:
            self.connection = sqlite3.connect(self.db_path)
            self.connection.row_factory = sqlite3.Row  # Enable dict-like access
            return True
        except Exception as e:
            print(f"‚ùå Database connection failed: {e}")
            return False
    
    def disconnect(self):
        """Close database connection"""
        if self.connection:
            self.connection.close()
            self.connection = None
    
    def create_table(self, table_name: str, columns: Dict[str, str]) -> bool:
        """
        Create a new table
        
        Args:
            table_name: Name of the table to create
            columns: Dict of column_name: column_type
        
        Returns:
            bool: True if successful
        """
        try:
            if not self.connection:
                self.connect()
            
            # Build CREATE TABLE statement
            column_definitions = []
            for col_name, col_type in columns.items():
                column_definitions.append(f"{col_name} {col_type}")
            
            sql = f"CREATE TABLE IF NOT EXISTS {table_name} ({', '.join(column_definitions)})"
            
            cursor = self.connection.cursor()
            cursor.execute(sql)
            self.connection.commit()
            
            print(f"‚úÖ Table '{table_name}' created successfully")
            return True
            
        except Exception as e:
            print(f"‚ùå Failed to create table '{table_name}': {e}")
            return False
    
    def insert_data(self, table_name: str, data: Dict[str, Any]) -> bool:
        """
        Insert data into a table
        
        Args:
            table_name: Name of the table
            data: Dictionary of column_name: value
        
        Returns:
            bool: True if successful
        """
        try:
            if not self.connection:
                self.connect()
            
            columns = ', '.join(data.keys())
            placeholders = ', '.join(['?' for _ in data])
            sql = f"INSERT INTO {table_name} ({columns}) VALUES ({placeholders})"
            
            cursor = self.connection.cursor()
            cursor.execute(sql, list(data.values()))
            self.connection.commit()
            
            print(f"‚úÖ Data inserted into '{table_name}' successfully")
            return True
            
        except Exception as e:
            print(f"‚ùå Failed to insert data into '{table_name}': {e}")
            return False
    
    def query_data(self, table_name: str, conditions: Dict[str, Any] = None) -> List[Dict]:
        """
        Query data from a table
        
        Args:
            table_name: Name of the table
            conditions: Optional WHERE conditions
        
        Returns:
            List of dictionaries representing rows
        """
        try:
            if not self.connection:
                self.connect()
            
            sql = f"SELECT * FROM {table_name}"
            params = []
            
            if conditions:
                where_clauses = []
                for col, val in conditions.items():
                    where_clauses.append(f"{col} = ?")
                    params.append(val)
                sql += f" WHERE {' AND '.join(where_clauses)}"
            
            cursor = self.connection.cursor()
            cursor.execute(sql, params)
            
            # Convert rows to dictionaries
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
            
        except Exception as e:
            print(f"‚ùå Failed to query data from '{table_name}': {e}")
            return []
    
    def update_data(self, table_name: str, data: Dict[str, Any], conditions: Dict[str, Any]) -> bool:
        """
        Update data in a table
        
        Args:
            table_name: Name of the table
            data: Dictionary of column_name: new_value
            conditions: Dictionary of column_name: condition_value for WHERE clause
        
        Returns:
            bool: True if successful
        """
        try:
            if not self.connection:
                self.connect()
            
            # Build SET clause
            set_clauses = []
            set_params = []
            for col, val in data.items():
                set_clauses.append(f"{col} = ?")
                set_params.append(val)
            
            # Build WHERE clause
            where_clauses = []
            where_params = []
            for col, val in conditions.items():
                where_clauses.append(f"{col} = ?")
                where_params.append(val)
            
            sql = f"UPDATE {table_name} SET {', '.join(set_clauses)} WHERE {' AND '.join(where_clauses)}"
            params = set_params + where_params
            
            cursor = self.connection.cursor()
            cursor.execute(sql, params)
            self.connection.commit()
            
            print(f"‚úÖ Data updated in '{table_name}' successfully")
            return True
            
        except Exception as e:
            print(f"‚ùå Failed to update data in '{table_name}': {e}")
            return False
    
    def delete_data(self, table_name: str, conditions: Dict[str, Any]) -> bool:
        """
        Delete data from a table
        
        Args:
            table_name: Name of the table
            conditions: Dictionary of column_name: condition_value for WHERE clause
        
        Returns:
            bool: True if successful
        """
        try:
            if not self.connection:
                self.connect()
            
            # Build WHERE clause
            where_clauses = []
            params = []
            for col, val in conditions.items():
                where_clauses.append(f"{col} = ?")
                params.append(val)
            
            sql = f"DELETE FROM {table_name} WHERE {' AND '.join(where_clauses)}"
            
            cursor = self.connection.cursor()
            cursor.execute(sql, params)
            self.connection.commit()
            
            print(f"‚úÖ Data deleted from '{table_name}' successfully")
            return True
            
        except Exception as e:
            print(f"‚ùå Failed to delete data from '{table_name}': {e}")
            return False

# Main functions for MCP integration
def create_database(db_path: str) -> Dict[str, Any]:
    """Create a new SQLite database"""
    tool = SQLiteDatabaseTool(db_path)
    if tool.connect():
        tool.disconnect()
        return {"status": "success", "message": f"Database created at {db_path}"}
    return {"status": "error", "message": "Failed to create database"}

def create_table_with_columns(db_path: str, table_name: str, columns_json: str) -> Dict[str, Any]:
    """Create a table with specified columns"""
    try:
        columns = json.loads(columns_json)
        tool = SQLiteDatabaseTool(db_path)
        
        if tool.create_table(table_name, columns):
            tool.disconnect()
            return {"status": "success", "message": f"Table '{table_name}' created"}
        
        tool.disconnect()
        return {"status": "error", "message": f"Failed to create table '{table_name}'"}
        
    except Exception as e:
        return {"status": "error", "message": f"Error: {e}"}

def insert_record(db_path: str, table_name: str, data_json: str) -> Dict[str, Any]:
    """Insert a record into a table"""
    try:
        data = json.loads(data_json)
        tool = SQLiteDatabaseTool(db_path)
        
        if tool.insert_data(table_name, data):
            tool.disconnect()
            return {"status": "success", "message": "Record inserted successfully"}
        
        tool.disconnect()
        return {"status": "error", "message": "Failed to insert record"}
        
    except Exception as e:
        return {"status": "error", "message": f"Error: {e}"}

def query_records(db_path: str, table_name: str, conditions_json: str = "{}") -> Dict[str, Any]:
    """Query records from a table"""
    try:
        conditions = json.loads(conditions_json) if conditions_json != "{}" else None
        tool = SQLiteDatabaseTool(db_path)
        
        results = tool.query_data(table_name, conditions)
        tool.disconnect()
        
        return {"status": "success", "data": results, "count": len(results)}
        
    except Exception as e:
        return {"status": "error", "message": f"Error: {e}"}

# Example usage
if __name__ == "__main__":
    # Demo the SQLite tool
    print("üóÑÔ∏è SQLite Database Tool Demo")
    
    # Create database and table
    result = create_database("demo.db")
    print(f"Database creation: {result}")
    
    # Create a users table
    columns = {"id": "INTEGER PRIMARY KEY", "name": "TEXT", "email": "TEXT"}
    result = create_table_with_columns("demo.db", "users", json.dumps(columns))
    print(f"Table creation: {result}")
    
    # Insert sample data
    user_data = {"name": "John Doe", "email": "john@example.com"}
    result = insert_record("demo.db", "users", json.dumps(user_data))
    print(f"Insert result: {result}")
    
    # Query data
    result = query_records("demo.db", "users")
    print(f"Query result: {result}")
